{
  "name": "Interface Feature Timed Automata (IFTA)",
  "tagline": "Building, composing, and analysing Timed Automata with variability and Reo",
  "body": "Interface Featured Timed Automata\r\n========\r\n\r\nThis project is a small Scala implementation of the Interface Featured Timed Automata (IFTA), that will include:\r\n\r\n - a small scala DSL\r\n - composition operator of IFTAs\r\n - export into UPPAAL Timed Automata with features\r\n\r\nBelow you will find a quick overview on how to build, visualise, compose, and analyse IFTA using our Scala library.\r\nFor more examples, please check our [examples folder](src/main/scala/ifta/examples).\r\n\r\n## Building primitive IFTAs\r\n\r\nTo compile and run the tools you can use [sbt](http://www.scala-sbt.org), for example, by executing the command ```sbt console```.\r\nThere, you can try the following commands:\r\n\r\n```scala\r\nimport ifta.DSL._\r\n\r\nval myAut = newifta ++ (\r\n    0 --> 1 by \"a,b\" when \"f\",\r\n    1 --> 0 by \"c\" when \"g\"\r\n    ) startWith 0 when \"g\"-->\"f\"\r\n// Create a simple automaton with 2 transitions and initial location \"0\".\r\n// \"f\" and \"g\" are features that must obey the constraint \"g -> f\", and\r\n// determine which edges exist.\r\n\r\nmyAut.isValid\r\n// returns \"true\", meaning that the feature model is non-empty (i.e., satisfiable).\r\n\r\nmyAut.instance  // or myAut.instance(\"f\") to refine\r\n// finds a concrete product (timed automaton), by selecting a valid product and instantiating the automaton.\r\n```\r\n\r\n\r\n## Visualising an automata and exporting to [Uppaal](http://uppaal.com)\r\n\r\nTo debug and analyse automata, three functions are provided to produce an intuitive `dot` graph file, an `xml` file that can be used by Uppaal, and an interactive `html` file using [Vis.js](http://visjs.org) to visualize an automata and see how it is affected by its possible feature selections.\r\n\r\n```scala\r\ntoDot(myAut)\r\n// outputs the automaton in dot format (for graphviz - https://mdaines.github.io/viz.js)\r\n\r\ntoUppaal(myAut get \"a\" pub \"b,c\",\"myAut.xml\")\r\n// produces an xml file that can be opened with Uppaal model checker, using \"a\" as an input channel and \"b\" and \"c\" as output channels\r\n\r\n// the application IFTA is defined in the examples folder\r\ntoVis(application, \"application.html\")\r\n// produces an html file that can be opened in a browser and see which transitions are enabled in each possible feature selection\r\n```\r\n\r\nThe `dot` output is handy to quickly visualise a connector with an intuitive layout (use, for example online tool [Viz.js](https://mdaines.github.io/viz.js/) to preview the produced graph). \r\nThe [Uppaal](http://uppaal.com) output requires some manual layout adjustments but can be used to simulate and to prove (temporal) properties.\r\nNote that the `Uppaal` model was extended to annotations to make `a` an input channel and `b` and `c` output channels, represented as `a?`, `b!`, and `c!` in the Uppaal model.\r\nThe `html` output is handy to see what possible feature selections are derived from the feature model and how they affect the transitions of the automata.\r\n\r\nScreenshots of the `dot`, `Uppaal`, and `Vis.js` outputs follow bellow.\r\nObserve that Uppaal does not support multiple actions per transition - these are rewritten as an interleaving of all combinations, imposing that inputs come before outputs (to reduce the state space).\r\n\r\n![alt text](https://cdn.rawgit.com/joseproenca/ifta/master/images/myAut.svg \"Automata example in Dot\")   ![alt text](https://cdn.rawgit.com/joseproenca/ifta/master/images/myAutUpp.svg \"Automata example in Uppaal\")\r\n![alt text](https://cdn.rawgit.com/joseproenca/ifta/master/images/application-toVis.gif \"Automata example in Vis\")\r\n## Time extension\r\n\r\nAutomata can be extended with clocks, using the same notion of clocks as Uppaal. Hence, states can have clock constraints as invariants, and edges can have clock constraints as guards that make a transition active.\r\n\r\nThe code below defines a simple coffee machine `cm`  with 2 features `cf` and `mk` (standing for coffee and milk), and with 3 actions: `co` (coffee), `ca` (cappuccino), and `b` (brew).\r\nTime is captured by the clock `c`, that is set to 0 every time the automata evolves to location 1, and is used to specify that the coffee will be brewed some time between 2 and 5 time units after selecting the product.\r\n\r\n\r\n```scala\r\nval cm = newifta ++ (\r\n    0 --> 1 by \"co\" when \"cf\"&&\"mk\" reset \"c\",\r\n    0 --> 1 by \"ca\" when \"cf\"       reset \"c\",\r\n    1 --> 0 by \"b\" cc \"c\">=2\r\n    ) startWith 0 when \"mk\"-->\"cf\" inv(1,\"c\"<=5) get \"co\" get \"ca\" pub \"b\"\r\n```\r\n\r\n\r\n## Composing automata\r\n\r\nTwo automata `a1` and `a2` can be composed in 2 ways:\r\n - `a1 * a2`: using the product of IFTA, which returns a new IFTA;\r\n - `a1 || a2`: creating a network of parallel IFTA, without calculating the product.\r\n\r\nAn example of these compositions follow below, using `sync` to rename ports that are connected (and need to be unified.\r\n\r\n```scala\r\nval cm = ... /* as before */\r\n\r\nval rtr = newifta ++ (\r\n    0 --> 1 by \"i\"  when \"vi\" && (\"vo1\"||\"vo2\"),\r\n    1 --> 0 by \"o1\" when \"vi\" && \"vo1\",\r\n    1 --> 0 by \"o2\" when \"vi\" && \"vo2\"\r\n    ) startWith 0 get \"i\" pub \"o1\" pub \"o2\"\r\n// or simply: val rtr = router(\"i\",\"o1\",\"o2\")\r\n\r\n// network of 2 automata (communicating over 2 pairs of ports)\r\nval netComp  = (cm || rtr) sync (\"o1\"->\"ca\",\"o2\"->\"co\")\r\n// flattened of the same 2 automata\r\nval prodComp = netComp.flatten\r\n  // same as (cm || rtr) product (\"o1\"->\"ca\",\"o2\"->\"co\")\r\n  // same as (cm sync (\"o1\"->\"ca\",\"o2\"->\"co\"))*(rtr sync (\"o1\"->\"ca\",\"o2\"->\"co\"))\r\n```\r\n\r\nThe automata of `cm`, `rtr`, and the product `prodComp` are depicted below, respectively.\r\nObserve that both compositions `netComp` and `prodComp` can be exported to Uppaal: the former using a network of automata, and the latter producing a single automaton.\r\n\r\n![alt text](https://cdn.rawgit.com/joseproenca/ifta/master/images/cm.svg \"Coffee Machine automaton in Dot\") ![alt text](https://cdn.rawgit.com/joseproenca/ifta/master/images/router.svg \"Router automaton in Dot\") ![alt text](https://cdn.rawgit.com/joseproenca/ifta/master/images/cm-router.svg \"Product of cm and rtr in Dot\")\r\n\r\nIn larger examples it is often necessary to visualise the composition of automata. This can be done, for example, as follows.\r\n\r\n```scala\r\ncon2dot( ((cm name \"CM\") || (rtr name \"Rt\")) sync link )\r\n// produces a dot graph depicting how the different IFTA of the network interact \r\n\r\n// seq3net is a NIFTA for a sequencer connector of three outputs. Its definition can be found in the examples folder\r\ncon2vis(seq3net, \"seq3net.html\")\r\n// produces a html file depicting how the different IFTA of the network interact\r\n// and how the feature selections derived from its feature model affect the precense of intefaces\r\n```\r\n\r\n![alt text](https://cdn.rawgit.com/joseproenca/ifta/master/images/cm-router-conn.svg \"Depicting the connector composing the coffee machine and the router\")\r\n![alt text](https://cdn.rawgit.com/joseproenca/ifta/master/images/seq3-con2vis.gif \"Depicting the network of a sequencer connector of 3 outputs\")",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}